import{_ as i,c as a,o as t,aH as n}from"./chunks/framework.CvJfJ0fb.js";const E=JSON.parse('{"title":"什么是命令式组件?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/what.md","filePath":"guide/what.md"}'),e={name:"guide/what.md"};function l(h,s,p,k,r,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="什么是命令式组件" tabindex="-1">什么是命令式组件? <a class="header-anchor" href="#什么是命令式组件" aria-label="Permalink to &quot;什么是命令式组件?&quot;">​</a></h1><h2 id="_1-命令式组件简介" tabindex="-1">1. <strong>命令式组件简介</strong> <a class="header-anchor" href="#_1-命令式组件简介" aria-label="Permalink to &quot;1. **命令式组件简介**&quot;">​</a></h2><p>命令式组件是一种特殊的组件使用方式，它允许开发者通过函数调用的方式来控制组件的显示和隐藏，而不是通过传统的模板声明方式。这种方式特别适合弹窗、提示框、确认框等临时性UI元素的管理。</p><p>通常我们对于命令式组件的控制,一般都是通过一个函数来控制,一个简单的伪代码示例来展示命令式组件通常的用法:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 命令式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">commandComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;标题&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;内容&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span></span></code></pre></div><p>如上,一个函数调用,就可以展示一个组件的全貌.</p><h2 id="_2-命令式组件的优点" tabindex="-1">2. <strong>命令式组件的优点</strong> <a class="header-anchor" href="#_2-命令式组件的优点" aria-label="Permalink to &quot;2. **命令式组件的优点**&quot;">​</a></h2><p>结合命令式组件的定义,可以总结出命令式组件的优点:</p><ul><li>非常灵活,开发体验更流畅</li><li>代码更简洁,易维护</li><li>符合直觉</li></ul><p>但是这些优点并不是鼓动你一股脑使用命令式组件,在现代ui开发中,声明式依然是绝大多数场景的最优解.而只有在一些特殊的场景中,使用命令式组件才会感受到幸福.</p><h2 id="_3-开发初衷" tabindex="-1">3. <strong>开发初衷</strong> <a class="header-anchor" href="#_3-开发初衷" aria-label="Permalink to &quot;3. **开发初衷**&quot;">​</a></h2><p>尽管声明式开发确实是现代UI框架的核心开发思想,这种开发范式适用于绝大部分场景,但是对于像弹窗开发这类场景来说声明开发范式实在是过于繁琐,如果一个页面弹窗很多的情况下,开发体验非常割裂,说是一种折磨也不为过.再者,唤起一个弹窗本身就是一个动作,一个命令=&gt;一个动作,所以命令式更加符合直觉 =.=;这也是我开发这个库的初衷.</p>`,12)]))}const g=i(e,[["render",l]]);export{E as __pageData,g as default};
